function H(){return typeof window<"u"&&typeof window.scrollY=="number"}function Z(){return!(typeof process>"u"||!process.cwd||!process.versions||typeof process.versions.node>"u"||!process.release||process.release.name!=="node")}function E(e,t){let n;{var r=Error.stackTraceLimit;Error.stackTraceLimit=1/0,n=new Error(e),Error.stackTraceLimit=r}return Z()&&(n.stack=M(n.stack,t)),n}function M(e,t){if(!e)return e;const n=te(e);let r=0;return n.filter(o=>o.includes(" (internal/")||o.includes(" (node:internal")?!1:r<t&&ee(o)?(r++,!1):!0).join(`
`)}function ee(e){return e.startsWith("    at ")}function te(e){return e.split(/\r?\n/)}function v(e,t){const n=globalThis[U]=globalThis[U]||{};return n[e]=n[e]||t}const U="_vike";function R(e){return typeof e=="object"&&e!==null}function ne(e){return Array.from(new Set(e))}const d=v("assertPackageInstances.ts",{instances:[],alreadyLogged:new Set}),re="The client runtime of Server Routing as well as the client runtime of Client Routing are both being loaded. Make sure they aren't loaded both at the same time for a given page. See https://vike.dev/client-runtimes-conflict",V="Two vike client runtime instances are being loaded. Make sure your client-side bundles don't include vike twice. (In order to reduce the size of your client-side JavaScript bundles.)";function z(){{const e=ne(d.instances);oe(e.length<=1,`Both vike@${e[0]} and vike@${e[1]} loaded. Only one version should be loaded.`)}d.checkSingleInstance&&d.instances.length>1&&j(!1,V,{onlyOnce:!0,showStackTrace:!0})}function Oe(e){j(d.isClientRouting!==!1,re,{onlyOnce:!0,showStackTrace:!0}),j(d.isClientRouting===void 0,V,{onlyOnce:!0,showStackTrace:!0}),d.isClientRouting=!0,e&&(d.checkSingleInstance=!0),z()}function ie(e){d.instances.push(e),z()}function oe(e,t){if(e)return;const n=`[vike][Wrong Usage] ${t}`;throw new Error(n)}function j(e,t,{onlyOnce:n,showStackTrace:r}){if(e)return;const i=`[vike][Warning] ${t}`;if(n){const{alreadyLogged:o}=d,a=n===!0?i:n;if(o.has(a))return;o.add(a)}console.warn(r?new Error(i):i)}const se="0.4.161",F={projectName:"Vike",projectVersion:se};ie(F.projectVersion);const D=new Proxy(e=>e,{get:()=>D}),u=D,c=v("utils/assert.ts",{alreadyLogged:new Set,logger(e,t){t==="info"?console.log(e):console.warn(e)},showStackTraceList:new WeakSet}),ae="[vike]",ce=`[vike@${F.projectVersion}]`,L=2;function s(e,t){var o;if(e)return;const n=(()=>{if(!t)return null;const a=typeof t=="string"?t:JSON.stringify(t);return u.dim(`Debug info (for Vike maintainers; you can ignore this): ${a}`)})();let r=["You stumbled upon a Vike bug.",`Go to ${u.blue("https://github.com/vikejs/vike/issues/new")} and copy-paste this error. A maintainer will fix the bug (usually under 24 hours).`,n].filter(Boolean).join(" ");r=y(r),r=T(r,"Bug"),r=b(r,!0);const i=E(r,L);throw(o=c.onBeforeLog)==null||o.call(c),i}function k(e,t,{showStackTrace:n}={}){var i;if(e)return;t=y(t),t=T(t,"Wrong Usage"),t=b(t);const r=E(t,L);throw n&&c.showStackTraceList.add(r),(i=c.onBeforeLog)==null||i.call(c),r}function ue(e){return e=y(e),e=T(e,"Error"),e=b(e),E(e,L)}function A(e,t,{onlyOnce:n,showStackTrace:r}){var i;if(!e){if(t=y(t),t=T(t,"Warning"),t=b(t),n){const{alreadyLogged:o}=c,a=n===!0?t:n;if(o.has(a))return;o.add(a)}if((i=c.onBeforeLog)==null||i.call(c),r){const o=new Error(t);c.showStackTraceList.add(o),c.logger(o,"warn")}else c.logger(t,"warn")}}function le(e,t,{onlyOnce:n}){var r;if(!e){if(t=y(t),t=b(t),n){const{alreadyLogged:i}=c,o=t;if(i.has(o))return;i.add(o)}(r=c.onBeforeLog)==null||r.call(c),c.logger(t,"info")}}function T(e,t){let n=`[${t}]`;const r=t==="Warning"?"yellow":"red";return n=u.bold(u[r](n)),`${n}${e}`}function y(e){return e.startsWith("[")?e:` ${e}`}function b(e,t=!1){return`${t?ce:ae}${e}`}const J=v("utils/assertRouterType.ts",{});function fe(){de(he()),J.isClientRouting=!0}function he(){return J.isClientRouting!==!1}function de(e){k(H(),`${u.cyan("import { something } from 'vike/client/router'")} is forbidden on the server-side`,{showStackTrace:!0}),A(e,"You shouldn't `import { something } from 'vike/client/router'` when using Server Routing. The 'vike/client/router' utilities work only with Client Routing. In particular, don't `import { navigate }` nor `import { prefetch }` as they unnecessarily bloat your client-side bundle sizes.",{showStackTrace:!0,onlyOnce:!0})}function C(e){const t=e/1e3;if(t<120){const n=I(t);return`${n} second${P(n)}`}{const n=t/60,r=I(n);return`${r} minute${P(r)}`}}function I(e){let t=e.toFixed(1);return t.endsWith(".0")&&(t=t.slice(0,-2)),t}function P(e){return e==="1"?"":"s"}const Y=v("utils/executeHook.ts",{userHookErrors:new WeakMap});function pe(e){return R(e)?Y.userHookErrors.get(e)??!1:!1}function Ue(e,t){const{hookName:n,hookFilePath:r,hookTimeout:{error:i,warning:o}}=t;let a,h;const g=new Promise((l,$)=>{a=p=>{w(),l(p)},h=p=>{w(),$(p)}}),w=()=>{m&&clearTimeout(m),f&&clearTimeout(f)},m=_(o)&&setTimeout(()=>{A(!1,`The ${n}() hook defined by ${r} is slow: it's taking more than ${C(o)} (https://vike.dev/hooksTimeout)`,{onlyOnce:!1})},o),f=_(i)&&setTimeout(()=>{const l=ue(`The ${n}() hook defined by ${r} timed out: it didn't finish after ${C(i)} (https://vike.dev/hooksTimeout)`);h(l)},i);return(async()=>{try{const l=await e();a(l)}catch(l){R(l)&&Y.userHookErrors.set(l,{hookName:n,hookFilePath:r}),h(l)}})(),g}function _(e){return!!e&&e!==1/0}function B(e,t,n){return typeof e=="string"?x(e.split(""),t,n).join(""):x(e,t,n)}function x(e,t,n){const r=[];let i=t>=0?t:e.length+t;s(i>=0&&i<=e.length);let o=n>=0?n:e.length+n;for(s(o>=0&&o<=e.length);!(i===o||(i===e.length&&(i=0),i===o));){const a=e[i];s(a!==void 0),r.push(a),i++}return r}const q=["http://","https://","tauri://"];function G(e){return q.some(t=>e.startsWith(t))||e.startsWith("/")||e.startsWith(".")||e.startsWith("?")||e.startsWith("#")||e===""}function Ce(e,t){s(t.includes(" but ")),k(typeof e=="string",`${t} should be a string`),!G(e)&&(!e.startsWith("/")&&!e.includes(":")?k(!1,`${t} is ${u.cyan(e)} and it should be /${u.cyan(e)} instead (URL pathnames should start with a leading slash)`):k(!1,`${t} isn't a valid URL`))}function Ie(e,t){s(G(e)),s(t.startsWith("/"));const[n,...r]=e.split("#");s(n!==void 0);const i=["",...r].join("#")||null;s(i===null||i.startsWith("#"));const o=i===null?"":S(i.slice(1)),[a,...h]=n.split("?");s(a!==void 0);const g=["",...h].join("?")||null;s(g===null||g.startsWith("?"));const w={},m={};Array.from(new URLSearchParams(g||"")).forEach(([W,O])=>{w[W]=O,m[W]=[...m.hasOwnProperty(W)?m[W]:[],O]});const{origin:f,pathname:l}=me(a,t);s(f===null||f===S(f)),s(l.startsWith("/")),s(f===null||e.startsWith(f));const $=a.slice((f||"").length);$e(e,f,$,g,i);let{pathname:p,hasBaseServer:X}=ye(l,t);return p=ge(p),s(p.startsWith("/")),{origin:f,pathname:p,pathnameOriginal:$,hasBaseServer:X,search:w,searchAll:m,searchOriginal:g,hash:o,hashOriginal:i}}function S(e){try{return decodeURIComponent(e)}catch{}try{return decodeURI(e)}catch{}return e}function ge(e){return e=e.replace(/\s+$/,""),e=e.split("/").map(t=>S(t).split("/").join("%2F")).join("/"),e}function me(e,t){var n;s(!e.includes("?")&&!e.includes("#"));{const{origin:r,pathname:i}=N(e);if(r)return{origin:r,pathname:i};s(i===e)}if(e.startsWith("/"))return{origin:null,pathname:e};{const r=typeof window<"u"?(n=window==null?void 0:window.document)==null?void 0:n.baseURI:void 0;let i;return r?i=N(r.split("?")[0]).pathname:i=t,{origin:null,pathname:ke(e,i)}}}function N(e){if(q.some(t=>e.startsWith(t))){const[t,n,r,...i]=e.split("/"),o=[t,n,r].join("/"),a=["",...i].join("/")||"/";return{origin:o,pathname:a}}else return{pathname:e,origin:null}}function ke(e,t){const n=t.split("/"),r=e.split("/");let i=t.endsWith("/");e.startsWith(".")&&n.pop();for(const a in r){const h=r[a];h==""&&a==="0"||h!="."&&(h==".."?n.pop():(i=!1,n.push(h)))}let o=n.join("/");return i&&!o.endsWith("/")&&(o+="/"),o.startsWith("/")||(o="/"+o),o}function we(e){s(e.startsWith("/")),s(!e.includes("?")),s(!e.includes("#"))}function ye(e,t){we(e),s(be(t));let n=e;if(s(n.startsWith("/")),s(t.startsWith("/")),t==="/")return{pathname:e,hasBaseServer:!0};let r=t;return t.endsWith("/")&&n===B(t,0,-1)&&(r=B(t,0,-1),s(n===r)),n.startsWith(r)?(s(n.startsWith("/")||n.startsWith("http")),s(n.startsWith(r)),n=n.slice(r.length),n.startsWith("/")||(n="/"+n),s(n.startsWith("/")),{pathname:n,hasBaseServer:!0}):{pathname:e,hasBaseServer:!1}}function be(e){return e.startsWith("/")}function $e(e,t,n,r,i){const o=We(t,n,r,i);s(e===o)}function We(e,t,n,r){return`${e||""}${t}${n||""}${r||""}`}function Re(e){return/^[a-z0-9][a-z0-9\.\+\-]*:/i.test(e)}function ve(e){return e instanceof Function||typeof e=="function"}function Te(e,t,n="unknown"){if(!R(e))return!1;if(!(t in e))return n==="undefined";if(n==="unknown")return!0;const r=e[t];return n==="array"?Array.isArray(r):n==="object"?R(r):n==="string[]"?Array.isArray(r)&&r.every(i=>typeof i=="string"):n==="function"?ve(r):Array.isArray(n)?typeof r=="string"&&n.includes(r):n==="null"?r===null:n==="undefined"?r===void 0:n==="true"?r===!0:n==="false"?r===!1:typeof r===n}function K(e,t){t&&Object.defineProperties(e,Object.getOwnPropertyDescriptors(t))}function je(e,t,n=r=>r){if(s(e.length>0),e.length===1)return n(e[0]);const r=e.slice(0,e.length-1),i=e[e.length-1];return r.map(n).join(", ")+` ${t} `+n(i)}H()&&fe();function Pe(e,t){const n="throw redirect()";Ae(e,n,!0);const r=[JSON.stringify(e)];t?(Ee(t,[301,302],"redirect"),r.push(String(t))):t=302;const i={};return K(i,{_abortCaller:n,_abortCall:`redirect(${r.join(", ")})`,_urlRedirect:{url:e,statusCode:t}}),Se(i)}function Se(e){const t=new Error("AbortRender");return K(t,{_pageContextAbort:e,[Q]:!0}),t}const Q="_isAbortError";function _e(e){return typeof e=="object"&&e!==null&&Q in e}function Be(e){return e._urlRewrite||e._urlRedirect||e.abortStatusCode?(s(Te(e,"_abortCall","string")),!0):!1}function xe(e,t,n){if(t)return;const r=n._urlRewrite??n.urlOriginal;s(r);const i=e._pageContextAbort._abortCall;s(i);const o=pe(e);let a="";o&&(a=` by ${u.cyan(`${o.hookName}()`)} hook defined at ${o.hookFilePath}`),le(!1,`${u.cyan(i)} thrown${a} while rendering ${u.cyan(r)}`,{onlyOnce:!1})}function Ee(e,t,n){const r=je(t.map(i=>i.toString()),"or");A(t.includes(e),`Unepexected status code ${e} passed to ${n}(), we recommend ${r} instead. (Or reach out at https://github.com/vikejs/vike/issues/1008 if you believe ${e} should be added.)`,{onlyOnce:!0})}function Ne(e){Le(e);const t={_urlRewrite:null};return e.forEach(n=>{Object.assign(t,n)}),t}function Le(e){const t=[];e.forEach(n=>{const r=n._urlRewrite;{const i=t.indexOf(r);if(i!==-1){const o=[...t.slice(i),r].map(a=>`render('${a}')`).join(" => ");k(!1,`Infinite loop of render() calls: ${o}`)}}t.push(r)})}function He(e,t){const n=[e>0&&u.cyan("throw render('/some-url')"),t>0&&u.cyan("throw redirect('/some-url')")].filter(Boolean).join(" and ");k(e+t<=7,`Maximum chain length of 7 ${n} exceeded. Did you define an infinite loop of ${n}?`)}function Ae(e,t,n){k(e.startsWith("/")||n&&Re(e),[`Invalid URL ${u.cyan(e)} passed to ${u.cyan(t)}:`,`the URL should start with ${u.cyan("/")}`,n&&`or a valid protocol (${u.cyan("https:")}, ${u.cyan("ipfs:")}, ...)`].filter(Boolean).join(" "))}export{Se as A,Ne as B,_e as C,xe as D,fe as a,k as b,he as c,s as d,R as e,ve as f,u as g,Te as h,H as i,v as j,A as k,K as l,Ue as m,Be as n,Oe as o,Ie as p,ue as q,Pe as r,B as s,be as t,ne as u,G as v,le as w,je as x,Ce as y,He as z};
